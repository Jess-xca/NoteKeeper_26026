# NoteKeeper Backend - Project Overview

## Authentication & Security

### JWT (JSON Web Tokens)
**What is it?**
JWT is a compact, URL-safe token format used for securely transmitting information between parties. In NoteKeeper, JWTs are used for stateless authentication.

**How it's used:**
1. User logs in with username/password
2. Backend validates credentials and generates a JWT containing user info
3. JWT is sent to frontend and stored (usually in localStorage)
4. Every subsequent request includes the JWT in the Authorization header: `Authorization: Bearer <token>`
5. Backend validates the JWT on each request to authenticate the user

**Why JWT?**
- Stateless: No session storage needed on the server
- Scalable: Works across multiple servers
- Secure: Cryptographically signed to prevent tampering
- Self-contained: Contains all necessary information about the user

**Implementation:**
- Library: `io.jsonwebtoken` (jjwt)
- Secret Key: Stored in `application.properties` as `jwt.secret`
- Token Expiration: 24 hours (configurable)
- Signing Algorithm: HS256 (HMAC with SHA-256)

**Example JWT Flow:**
```
Login Request → Validate Credentials → Generate JWT → Return Token
↓
Frontend stores token
↓
API Request with "Authorization: Bearer <token>"
↓
JwtAuthenticationFilter extracts & validates token
↓
Sets Authentication in SecurityContext
↓
Endpoint processes request with authenticated user
```

### BCrypt Password Hashing
**What is it?**
BCrypt is a password hashing function designed to be slow, making brute-force attacks impractical.

**How it's used:**
```java
// During registration
String hashedPassword = passwordEncoder.encode(plainTextPassword);
user.setPassword(hashedPassword);

// During login
if (passwordEncoder.matches(providedPassword, storedHashedPassword)) {
    // Password correct
}
```

**Why BCrypt?**
- Adaptive: Can increase rounds as computers get faster
- Salt automatically included
- Industry standard for password security

### Spring Security Configuration
**Components:**
1. `SecurityConfig.java` - Main security configuration
   - Configures which endpoints are public vs. authenticated
   - Sets up JWT filter
   - Disables session management (stateless)
   - Configures CORS for frontend access

2. `JwtAuthenticationFilter.java` - Intercepts every request
   - Extracts JWT from Authorization header
   - Validates token
   - Sets user in SecurityContext

3. `CustomUserDetailsService.java` - Loads user for authentication
   - Implements Spring Security's `UserDetailsService`
   - Returns `UserPrincipal` wrapping our `User` entity

4. `UserPrincipal.java` - Wraps User for Spring Security
   - Implements `UserDetails` interface
   - Provides user info to Security Context
   - Enables `@AuthenticationPrincipal` in controllers

**Public Endpoints** (no authentication required):
- `/api/auth/**` - login, register, password reset
- `/api/users` (POST only) - user registration
- `/api/locations/**` - location lookups
- `/api/profiles/**` - profile access
- `/h2-console/**` - database console (dev only)

**Protected Endpoints** (require valid JWT):
- All other `/api/**` endpoints

### Two-Factor Authentication (2FA)
**How it works:**
1. User enables 2FA in their profile
2. On

 login, if 2FA is enabled:
   - Backend generates 6-digit code
   - Code sent to user's email via SMTP
   - Login response includes `requiresTwoFactor: true`
3. Frontend prompts for 2FA code
4. User enters code, backend validates
5. If valid, returns full JWT token

**Implementation:**
- Random 6-digit code generation
- Stored in `two_factor_codes` table with expiration
- Email sent via `EmailService`
- Code valid for 10 minutes

## Location Management

### Rwanda Location Hierarchy
**Structure:**
1. Province (5 provinces)
2. District (30 districts)
3. Sector (~416 sectors)
4. Cell (~2,148 cells)
5. Village (~14,837 villages)

**How it's loaded:**
- `JsonLocationLoader.java` runs on application startup
- Reads from `resources/Location.json`
- Loads hierarchically (provinces → districts → sectors → cells → villages)
- Uses parent-child relationships
- Stores in `locations` table

**API Usage:**
```
GET /api/locations/provinces → All provinces
GET /api/locations/{provinceId}/children → Districts in province
GET /api/locations/{districtId}/children → Sectors in district
etc.
```

**Why this approach?**
- Accurate Rwanda administrative structure
- Efficient hierarchical queries
- Supports user location assignment
- Can filter/search users by location

## Email Service (SMTP)

**What is it?**
SMTP (Simple Mail Transfer Protocol) is used to send emails from the application.

**How it's configured:**
```properties
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=your-email@gmail.com
spring.mail.password=your-app-password
```

**What it's used for:**
1. **2FA Codes** - Sends 6-digit verification codes
2. **Password Reset** - Sends reset links
3. **Welcome Emails** - Sends welcome message on registration (optional)
4. **Notifications** - Can send email notifications for workspace invites (optional)

**Implementation:**
- `EmailService.java` wraps Spring's `JavaMailSender`
- Uses MimeMessage for HTML emails
- Error handling for failed sends

## Database Schema

### Core Tables
1. **users** - User accounts and authentication
2. **user_profiles** - Extended user information
3. **workspaces** - User workspaces/folders
4. **pages** - Note pages/documents
5. **tags** - Custom tags for organization
6. **locations** - Rwanda administrative divisions

### Relationship Tables
7. **workspace_members** - Many-to-many users ↔ workspaces with roles
8. **page_tags** - Many-to-many pages ↔ tags
9. **page_shares** - Page sharing with specific users

### Supporting Tables
10. **attachments** - Files attached to pages
11. **notifications** - User notifications
12. **password_reset_tokens** - Temporary tokens for password reset
13. **two_factor_codes** - Temporary 2FA verification codes

## Technology Stack

### Backend
- **Framework**: Spring Boot 3.5.7
- **Language**: Java 17
- **Database**: H2 (development), can use PostgreSQL (production)
- **ORM**: Hibernate/JPA
- **Security**: Spring Security 6.2.12
- **JWT**: jjwt 0.12.6
- **Email**: Spring Boot Starter Mail
- **Build Tool**: Maven

### Key Dependencies
- spring-boot-starter-web - REST API
- spring-boot-starter-data-jpa - Database access
- spring-boot-starter-security - Authentication/authorization
- spring-boot-starter-mail - Email sending
- jjwt-api, jjwt-impl, jjwt-jackson - JWT handling
- lombok - Reduce boilerplate (optional)

## Architecture Patterns

### Exception-Based Error Handling
- Custom exceptions: `ResourceNotFoundException`, `BadRequestException`
- `GlobalExceptionHandler` catches all exceptions
- Returns consistent JSON error responses
- Eliminates manual try-catch in controllers

### Service Layer Pattern
- Controllers handle HTTP requests/responses
- Services contain business logic
- Repositories handle database access
- Clear separation of concerns

### DTO Pattern
- DTOs (Data Transfer Objects) for API responses
- Hides internal entity structure
- Can customize what data is exposed
- `DTOMapper` converts entities ↔ DTOs

### Transactional Boundaries
- `@Transactional` on all write operations
- Ensures atomicity (all-or-nothing)
- Automatic rollback on exceptions
- Prevents partial state changes

## Development & Testing

### Running the Application
```bash
# Backend
cd notekeeper
mvn spring-boot:run

# Access at http://localhost:8080
```

### Database Console
- H2 Console: http://localhost:8080/h2-console
- JDBC URL: `jdbc:h2:mem:testdb`
- Username: `sa`
- Password: (empty)

### Testing
- Unit tests: `mvn test`
- Integration tests: Use Postman or curl
- Browser testing: Frontend at http://localhost:3000

## Security Best Practices

1. **Never expose raw passwords** - Always hash with BCrypt
2. **Validate all inputs** - Prevent SQL injection, XSS
3. **Use HTTPS in production** - Encrypt data in transit
4. **Rotate JWT secret regularly** - Use environment variables
5. **Set appropriate CORS** - Only allow trusted origins
6. **Implement rate limiting** - Prevent brute-force attacks (TODO)
7. **Log security events** - Monitor for suspicious activity
8. **Keep dependencies updated** - Patch security vulnerabilities
