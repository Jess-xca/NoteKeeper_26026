# NoteKeeper - Advanced Note-Taking Application

## Project Overview

NoteKeeper is a comprehensive note-taking application built with Spring Boot that provides users with powerful tools for organizing, managing, and sharing their notes. The application features a hierarchical workspace system, rich text editing, tagging, file attachments, and collaborative features.

## Key Features

### Core Functionality
- **User Management**: Registration, authentication, and profile management
- **Workspace Organization**: Hierarchical workspace structure for organizing notes
- **Rich Note Editing**: Create and edit pages with rich content
- **Tagging System**: Organize notes with customizable tags
- **File Attachments**: Upload and manage file attachments to notes
- **Sharing & Collaboration**: Share notes with other users
- **Notifications**: Real-time notifications for important events

### Security Features
- **JWT Authentication**: Secure token-based authentication
- **Two-Factor Authentication (2FA)**: Enhanced security with 2FA support
- **Role-Based Access Control**: Admin and user roles with different permissions
- **Password Reset**: Secure password recovery mechanism
- **Google OAuth Integration**: Login with Google accounts

### Advanced Features
- **Location-Based Data**: Pre-loaded with Rwanda's administrative divisions
- **Email Notifications**: SMTP-based email sending for notifications
- **File Upload Management**: Configurable file size limits and storage
- **Audit Logging**: Track user activities and system events

## Technology Stack

### Backend
- **Framework**: Spring Boot 3.5.7
- **Language**: Java 17
- **Database**: PostgreSQL
- **ORM**: Spring Data JPA with Hibernate
- **Security**: Spring Security with JWT
- **Build Tool**: Maven

### Key Dependencies
- **Spring Boot Starter Web**: REST API development
- **Spring Boot Starter Data JPA**: Database operations
- **Spring Boot Starter Security**: Authentication and authorization
- **Spring Boot Starter Mail**: Email functionality
- **Spring Boot Starter Validation**: Input validation
- **JJWT**: JSON Web Token handling
- **Google API Client**: OAuth2 integration
- **PostgreSQL Driver**: Database connectivity

## Architecture

### Layered Architecture
The application follows a clean layered architecture:

1. **Controller Layer**: REST API endpoints handling HTTP requests
2. **Service Layer**: Business logic and data processing
3. **Repository Layer**: Data access and persistence
4. **Model Layer**: Entity definitions and data structures
5. **DTO Layer**: Data transfer objects for API communication
6. **Security Layer**: Authentication and authorization components

### Database Schema
The application uses a relational database with the following main entities:

- **Users**: User accounts and profiles
- **Workspaces**: Organizational containers for notes
- **Pages**: Individual notes with rich content
- **Tags**: Categorization system for notes
- **Attachments**: File uploads associated with notes
- **Locations**: Hierarchical location data (Province → District → Sector → Cell → Village)
- **Notifications**: System notifications
- **Page Shares**: Note sharing functionality
- **Workspace Members**: Collaborative workspace access

### Security Architecture
- **JWT Tokens**: Stateless authentication with refresh tokens
- **Password Encryption**: BCrypt hashing for secure password storage
- **Role-Based Permissions**: ADMIN and USER roles with different access levels
- **CORS Configuration**: Cross-origin resource sharing setup
- **Request Filtering**: Custom filters for authentication and logging

## API Design

### RESTful Endpoints
The API follows REST principles with consistent URL patterns:
- `GET /api/resource` - List resources
- `GET /api/resource/{id}` - Get specific resource
- `POST /api/resource` - Create new resource
- `PUT /api/resource/{id}` - Update resource
- `DELETE /api/resource/{id}` - Delete resource

### Response Format
All API responses follow a consistent JSON structure with proper HTTP status codes.

### Authentication
Protected endpoints require JWT tokens in the Authorization header:
```
Authorization: Bearer <jwt-token>
```

## Development Setup

### Prerequisites
- Java 17 or higher
- Maven 3.6+
- PostgreSQL 12+
- Git

### Configuration
The application uses `application.properties` for configuration:
- Database connection settings
- JWT secret configuration
- Email server settings
- File upload limits
- Google OAuth credentials

### Running the Application
1. Clone the repository
2. Configure PostgreSQL database
3. Update `application.properties` with your settings
4. Run with Maven: `mvn spring-boot:run`
5. Access at `http://localhost:8080`

## Deployment

### Production Considerations
- **Database**: Use connection pooling and proper indexing
- **Security**: Configure HTTPS and secure JWT secrets
- **File Storage**: Consider cloud storage for attachments
- **Monitoring**: Implement logging and health checks
- **Scaling**: Design for horizontal scaling if needed

### Environment Variables
For production deployment, use environment variables for sensitive configuration:
- Database credentials
- JWT secrets
- Email server credentials
- Google OAuth secrets

## Future Enhancements

### Planned Features
- Real-time collaboration with WebSocket
- Advanced search and filtering
- Note templates and automation
- Mobile application
- Integration with external services
- Advanced analytics and reporting

### Technical Improvements
- Microservices architecture consideration
- GraphQL API implementation
- Caching layer (Redis)
- Message queue integration
- Containerization with Docker/Kubernetes

## Contributing

### Code Standards
- Follow Java naming conventions
- Use meaningful variable and method names
- Add comprehensive documentation
- Write unit tests for new features
- Follow REST API best practices

### Development Workflow
1. Create feature branch from main
2. Implement changes with tests
3. Ensure code compiles and tests pass
4. Submit pull request with description
5. Code review and merge

## Support

For questions, issues, or contributions, please refer to the project documentation or contact the development team.
